<p>フィヨルドブートキャンプのライトニングトーク会に先日参加し、Rack について話したのでスライドと学んで得た内容を書く。</p>

<!-- more -->

<p>最初にライトニングトーク会へ参加するというのだけ決めて、テーマは後から考えた。</p>

<p>Ruby の gem である OmniAuth を使っているときにミドルウェアの概念に出会ったので、よくわかっていないミドルウェアのことを学ぶいい機会だなと思ったので発表テーマに選んで、Rack を触ってみた。</p>

<h1 id="発表したスライド">発表したスライド</h1>

<p><a href="https://speakerdeck.com/ot0m1/rack-karajian-rumidoruueafalseshi-jie">https://speakerdeck.com/ot0m1/rack-karajian-rumidoruueafalseshi-jie</a></p>

<h1 id="発表した内容">発表した内容</h1>

<p>Rack から見るミドルウェアの世界というタイトルで、ミドルウェアってどんなものか、Rack とはなんぞや、Rack を触ってみてどうかをお話します。</p>

<h2 id="なぜ-rack-を触ろうと思ったか">なぜ Rack を触ろうと思ったか</h2>

<p>「omniauth を使って GitHub 認証を実装する」のプラクティスをやっているときに読んだパーフェクト Ruby on Rails に、
OmniAuthはRackミドルウェアとして動作する、という記述があったためです。<br />
ミドルウェアとは？アクセスを受け取るとは？どんな動きをしているのかというところを調べたかったのが動機になります。</p>

<h2 id="rack-とは">Rack とは</h2>

<p>自分で調べたところ、WEB サーバと WEB アプリケーション／フレームワーク間のインターフェースの役割を果たすライブラリ、とのことでした</p>

<h2 id="なぜ-web-サーバと-web-アプリケーションフレームワーク間のインターフェースの役割を果たすライブラリがあるとうれしいのかなぜ-rack-ができたのか">なぜ WEB サーバと WEB アプリケーション／フレームワーク間のインターフェースの役割を果たすライブラリがあるとうれしいのか、なぜ Rack ができたのか</h2>

<p>参考にした <a href="https://gihyo.jp/dev/serial/01/ruby/0023">URL</a> に次のような経緯が書かれてありました。</p>

<ul>
  <li>WSGI という、Python のための Web サーバと Web アプリケーション/フレームワーク間の標準インターフェースを定める仕様があり、Rack はこの WSGI に影響されて開発された</li>
  <li>各フレームワークの実装は特定の Web サーバに依存していることが多く，使用したいフレームワークの為に環境を制限されるということがあったため、WSGI という標準インターフェイスを定める仕様が提唱された</li>
  <li>様々な Web サーバやフレームワークが開発されても，双方が Rack を使用してインターフェース部分を実装していさえすれば、サーバとアプリケーションの組み合わせを気にしなくてよくなる</li>
</ul>

<p>という経緯とうれしい理由があるようです。</p>

<p>フィヨルドブートキャンプのプラクティスでも出てくる Sinatora や Ruby on Rails でもこの Rack は使われているようです。</p>

<p>というわけでさっそく触ってみます。</p>

<p>まずは Rack でアプリケーションを作ってみて、インターフェイスに触れてみます。<br />
Rack のアプリケーションとしてはスライドに書かれている最低限 3つのことを満たせばよいそうです。</p>

<p>はいできました。</p>

<p><a href="https://github.com/ot0m1/sibatora">https://github.com/ot0m1/sibatora</a></p>

<p>GET リクエストでフォームを描画して、POST でフォームに書かれた内容を受け取って表示するというものです。</p>

<p>shibatora という名称は Sinatra から来ています。<br />
当初 Sinatra をモチーフにルーティングができるウェブアプリケーションフレームワークを作ろうとしていたんですが、ミドルウェアの動きを見たいのが今回の目的なので、あんまり複雑なことをやっても本題からずれるなと思って上記のような簡単な挙動のアプリケーションにしました。その時の名残で名前だけ引き継いでいます。</p>

<p>Rack が色々やってくれるので Web サーバのことを書かなくても、<code class="language-plaintext highlighter-rouge">rackup</code> すれば自動でサーバを起動して、ブラウザでアクセスできるようにしてくれます。<br />
Sinatra や Ruby on Rails を起動させるのと同じ仕様感でした。</p>

<p>ここで確かに Sinatra や Ruby on Rails も Rack が使われており、アプリケーションはサーバのことを意識しなくてよいということなのかなということを感じました。</p>

<h2 id="さらに-rack-でミドルウェア的なものも作ってみる">さらに Rack でミドルウェア的なものも作ってみる</h2>

<p>できました。</p>

<p>冒頭でお話した OmniAuth と同じように、サーバとアプリケーションの中間に入って振る舞ってもらうようなものを作ります。</p>

<p>というわけで、ウェブアプリケーションフレームじゃないほうの WAF（ウェブアプリケーションファイアウォール）を作ってみました。
shibatora_waf.rb というファイルを追加しています。さっきのアプリケーションのフォームに URL が書き込まれたら警告文とステータスコード 403 を返すようにようにするというものです。</p>

<p>サーバーが動いているので <code class="language-plaintext highlighter-rouge">curl</code> がたたけるため、このようにコマンドラインでも確認できます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-&gt; %  curl http://127.0.0.1:9292/ <span class="nt">-X</span> POST <span class="nt">-d</span> <span class="s1">'hello'</span> <span class="nt">-i</span>
HTTP/1.1 200 OK
Content-Type: text/html<span class="p">;</span><span class="nv">charset</span><span class="o">=</span>utf-8
Content-Length: 31

&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;%

-&gt; % curl http://127.0.0.1:9292/ <span class="nt">-X</span> POST <span class="nt">-d</span> <span class="s1">'https://example.com'</span> <span class="nt">-i</span>
HTTP/1.1 403 Forbidden
Content-Type: text/html<span class="p">;</span><span class="nv">charset</span><span class="o">=</span>utf-8
Content-Length: 68

&lt;html&gt;&lt;body&gt;URLを含む文章は投稿できません&lt;/body&gt;&lt;/html&gt;%
</code></pre></div></div>

<p>このように、ミドルウェアとして動いていることが確認できます。
shibatora_waf.rb がミドルウェアとして振る舞ってくれ、サーバとアプリケーションの間の通信に割り込んでいるということがわかります。</p>

<p>コードを書く側は、アプリケーション層だけを意識しておけばよく、その下の層において Rack がいい感じに HTTP のレスポンスを操作してくれています。</p>

<p>というわけで冒頭の OmniAuth の振る舞いをなんとなくイメージできました。</p>
